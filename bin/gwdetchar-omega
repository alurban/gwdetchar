#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Compute an omega scan for a list of channels around a given GPS time.
"""

from __future__ import division

import os
import re
import sys
import warnings
from StringIO import StringIO

import numpy
from numpy import fft as npfft
from scipy.signal import butter

from matplotlib import (use, rcParams)
use('agg')  # nopep8

from gwpy.utils import gprint
from gwpy.time import tconvert
from gwpy.table import EventTable
from gwpy.timeseries import TimeSeriesDict
from gwpy.detector import (Channel, ChannelList)
from gwpy.signal.qtransform import QTiling

from gwdetchar import (cli, __version__)
from gwdetchar.omega import (config, plot, html)

__author__ = 'Alex Urban <alexander.urban@ligo.org>'
__credits__ = 'Duncan Macleod <duncan.macleod@ligo.org>'


# -- parse command line -------------------------------------------------------

parser = cli.create_parser(description=__doc__)
parser.add_argument('ifo', type=str, help='IFO prefix for this analysis')
parser.add_argument('gpstime', type=str, help='GPS time of scan')
parser.add_argument('-o', '--output-directory',
                    help='output directory for the omega scan, '
                         'default: ~/public_html/wdq/{IFO}_{gpstime}')
parser.add_argument('-f', '--config-file', action='append', default=None,
                    help='path to configuration file to use, can be given '
                         'multiple times (files read in order), default: '
                         'None')
parser.add_argument('--condor', action='store_true', default=False,
                    help='indicates this job is running under condor, '
                         'only use when running as part of a workflow')
parser.add_argument('--colormap', default='viridis',
                    help='name of colormap to use, default: %(default)s')
parser.add_argument('-v', '--verbose', action='store_true', default='False',
                    help='print verbose output, default: %(default)s')
cli.add_nproc_option(parser)

args = parser.parse_args()

print("----------------------------------------------\n"
      "Creating %s omega scan at GPS second %s..." % (args.ifo, args.gpstime))

gpstime = args.gpstime
gps = float(gpstime)
ifo = args.ifo
obs = ifo[0]

# set output directory
outdir = args.output_directory
if outdir is None:
    outdir = os.path.expanduser('~/public_html/wdq/%s_%s' % (ifo, gps))
if not os.path.isdir(outdir):
    os.makedirs(outdir)
os.chdir(outdir)
print("Output directory created as %s" % outdir)

# parse configuration file
cp = config.OmegaConfigParser(ifo=ifo)
cp.read(args.config_file)

# prepare html variables
htmlv = {
    'title': '%s Qscan | %s' % (ifo, gps),
    'config': args.config_file,
}


# -- FIXME: Eventually move these classes to gwdetchar.omega ------------------

class OmegaChannel(Channel):
    def __init__(self, channelname, section, **params):
        self.name = channelname
        frametype = params.get('frametype', None)
        frange = tuple(
            [float(s) for s in params.get('frequency-range', None).split(',')]
        )
<<<<<<< HEAD
        qrange = tuple(
            [float(s) for s in params.get('q-range', None).split(',')]
        )
        mismatch = float(params.get('max-mismatch', 0.2))
        snrthresh = float(params.get('snr-threshold', 5.5))
        super(OmegaChannel, self).__init__(channelname, frametype=frametype,
                                           frange=frange, qrange=qrange,
                                           mismatch=mismatch,
                                           snrthresh=snrthresh)
=======
        super(OmegaChannel, self).__init__(channelname, frametype=frametype,
                                           frange=frange)
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
        self.plots = {}
        for plottype in ['timeseries_raw', 'timeseries_highpassed',
                         'timeseries_whitened', 'qscan_raw',
                         'qscan_whitened', 'qscan_autoscaled',
                         'eventgram_raw', 'eventgram_whitened',
                         'eventgram_autoscaled']:
            self.plots[plottype] = [get_fancyplots(self.name, plottype, t)
                                    for t in [1, 4]]
        self.section = section
        self.params = params.copy()


class OmegaChannelList(object):
    def __init__(self, **params):
        self.name = params.get('name', None)
        self.key = self.name.lower().replace(' ', '-')
<<<<<<< HEAD
        self.duration = int(params.get('duration', 32))
        self.fftlength = int(params.get('fftlength', 2))
        self.resample = int(params.get('resample', 0))
=======
        self.duration = int(params.get('duration', None))
        self.fftlength = int(params.get('fftlength', None))
        self.resample = int(params.get('resample', None))
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
        self.frametype = params.get('frametype', None)
        chans = params.get('channels', None).split(',\n')
        self.channels = [OmegaChannel(c, self.name, **params) for c in chans]
        self.params = params.copy()


# -- Utilities ----------------------------------------------------------------

def get_fancyplots(channel, plottype, duration, caption=None):
    """Construct FancyPlot objects for output HTML pages

    Parameters
    ----------
    channel : `str`
        the name of the channel
    plottype : `str`
        the type of plot, e.g. 'raw_timeseries'
    duration : `str`
        duration of the plot, in seconds
    caption : `str`, optional
        a caption to render in the fancybox
    """
    plotdir = 'plots'
    chan = channel.replace('-', '_').replace(':', '-')
    filename = '%s/%s-%s-%s.png' % (plotdir, chan, plottype, duration)
    if not caption:
        caption = os.path.basename(filename)
    return html.FancyPlot(filename, caption)


def get_widths(x0, xdata):
    """Generator to get the width of 1-D rectangular tiles

    Parameters
    ----------
    x0 : `float`
        starting point of the first tile
    xdata : `array`
        center points of all tiles
    """
    for x in xdata:
        width = 2 * (x - x0)
        x0 = x + width/2
        yield width


def eventgram(time, data, search=0.5, frange=(0, numpy.inf),
<<<<<<< HEAD
              qrange=(4, 96), snrthresh=5.5, mismatch=0.2):
=======
              qrange=(4, 96), snrthresh=5.5):
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
    """Create an eventgram with the Q-plane that has the most significant
    tile.

    Parameters
    ----------
    time : `float` or `int`
        central GPS time of the search, in seconds
    data : `TimeSeries`
        timeseries data to analyze
    search : `float`, optional
        search analysis window, will be centered at `time`
    frange : `tuple` of `float`, optional
        `(low, high)` range of frequencies to scan
    qrange : `tuple` of `float`, optional
        `(low, high)` range of Qs to scan
    snrthresh : `float`
        threshold on tile SNR, tiles quieter than this will not be included
<<<<<<< HEAD
    mismatch : `float`
        the maximum fractional mismatch between neighboring tiles
=======
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0

    Returns
    -------
    table : `gwpy.table.EventTable`
        an `EventTable` object containing all tiles louder than `snrthresh` on
        the Q plane with the loudest tile
    """
    # generate tilings
    planes = QTiling(abs(data.span), data.sample_rate.value, qrange=qrange,
<<<<<<< HEAD
                     frange=frange, mismatch=mismatch)
=======
                     frange=frange)
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0

    # get frequency domain data
    fdata = data.fft().value

    # set up results
<<<<<<< HEAD
    Z = 0  # max normalized tile energy
    N = 0  # no. of independent tiles
    numplanes = 0
    qmax, qmin = qrange[1], qrange[0]
    pweight = (1 + numpy.log10(qmax/qmin)/numpy.sqrt(2))

    # Q-transform data for each `(Q, frequency)` tile
    for plane in planes:
        n_ind = 0
        numplanes += 1
        freqs, normenergies = plane.transform(fdata, epoch=data.x0)
        # find peak energy in this plane and record if loudest
        for freq, ts in zip(freqs, normenergies):
            n_ind += 1 + 2 * numpy.pi * abs(data.span) * freq / plane.q
=======
    Z = 0

    # Q-transform data for each `(Q, frequency)` tile
    for plane in planes:
        freqs, normenergies = plane.transform(fdata, epoch=data.x0)
        # find peak energy in this plane and record if loudest
        for freq, ts in zip(freqs, normenergies):
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
            peak = ts.crop(time-search/2, time+search/2).value.max()
            if peak > Z:
                Z = peak
                snr = numpy.sqrt(2*Z)
                fc = freq
                ts_cropped = ts.crop(time-search/2, time+search/2)
                tc = ts_cropped.times.value[ts_cropped.value.argmax()]
                del ts_cropped
                peakplane = plane
<<<<<<< HEAD
        N += n_ind * pweight / numplanes
=======
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0

    # create an eventgram for the plane with the loudest tile
    energies = []
    central_times, central_freqs, durations, bandwidths = [], [], [], []
    freqs, normenergies = peakplane.transform(fdata, epoch=data.x0)
    bws = get_widths(peakplane.frange[0], freqs)
    for f, b, ts in zip(freqs, bws, normenergies):
        durs = get_widths(data.x0.value, ts.times.value)
        for t, dur, E in zip(ts.times.value, durs, ts.value):
            if E >= snrthresh**2/2:
                central_freqs.append(f)
                bandwidths.append(b)
                central_times.append(t)
                durations.append(dur)
                energies.append(E)
    table = EventTable([central_times, central_freqs, durations,
                       bandwidths, energies],
                       names=('central_time', 'central_freq', 'duration',
                       'bandwidth', 'energy'))

    # get parameters and return
    table.q = peakplane.q
    table.Z = Z
    table.snr = snr
    table.tc = tc
    table.fc = fc
    table.frange = peakplane.frange
<<<<<<< HEAD
    table.engthresh = -numpy.log10(1e-3 * abs(data.span) / (1.5 * N))
=======
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
    return table


# -- Compute Qscan ------------------------------------------------------------

gprint('Computing Q-scans...')

# make subdirectories
plotdir = 'plots'
aboutdir = 'about'
for d in [plotdir, aboutdir]:
    if not os.path.isdir(d):
        os.makedirs(d)

# determine channel blocks
blocks = [OmegaChannelList(**cp[s]) for s in cp.sections()]

# range over blocks
for block in blocks:
    gprint('Processing block %s' % block.name)
    chans = [c.name for c in block.channels]
    # read in fftlength seconds of data
    # centered on gps
    duration = block.duration
    fftlength = block.fftlength
    data = TimeSeriesDict.get(chans, gps-256-fftlength/4, gps+256+fftlength/4,
                              frametype=block.frametype, nproc=args.nproc,
                              verbose=args.verbose)
    # compute qscans
    for c in block.channels:
        if args.verbose:
            gprint('Computing omega scans for channel %s...' % c.name)

        # get raw timeseries
<<<<<<< HEAD
        series = data[c.name]
        if block.resample:
            series = series.resample(block.resample)

        # filter the timeseries
        hpseries = series.highpass(10, gpass=.5, filtfilt=True)
=======
        series = data[c.name].resample(block.resample)

        # filter the timeseries
        hpseries = series.highpass(10)
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
        asd = series.asd(fftlength, fftlength/2, method='lal_median_mean')
        wseries = hpseries.whiten(fftlength, fftlength/2, window='hann',
                                  asd=asd)

        # crop the timeseries
        wseries = wseries.crop(gps-duration/2, gps+duration/2)
        hpseries = hpseries.crop(gps-duration/2, gps+duration/2)

        # compute eventgrams
<<<<<<< HEAD
        table = eventgram(gps, wseries, frange=c.frange, qrange=c.qrange,
                          snrthresh=c.snrthresh, mismatch=c.mismatch)
        if table.Z < table.engthresh:
            gprint('Channel %s not significant at white noise false rate 1e-3'
                   % c.name)
            del series, hpseries, wseries, asd, table
        Q = table.q
        rtable = eventgram(gps, hpseries, frange=table.frange, qrange=(Q, Q),
                           snrthresh=c.snrthresh, mismatch=c.mismatch)
=======
        table = eventgram(gps, wseries, frange=c.frange)
        Q = table.q
        rtable = eventgram(gps, hpseries, frange=table.frange, qrange=(Q, Q))
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0

        # compute Q-transforms
        qscan = wseries.q_transform(qrange=(Q, Q), frange=c.frange,
                                    tres=0.002, fres=0.1, gps=gps,
                                    search=0.25, whiten=False)
        rqscan = hpseries.q_transform(qrange=(Q, Q), frange=c.frange,
                                      tres=0.002, fres=0.1, gps=gps,
                                      search=0.25, whiten=False)

        # prepare plots
        if args.verbose:
            gprint('Plotting omega scans for channel %s...' % c.name)
        for span, png1, png2, png3, png4, png5, png6, png7, png8, png9 in zip(
<<<<<<< HEAD
            [1, 4], c.plots['qscan_whitened'],
            c.plots['qscan_autoscaled'], c.plots['qscan_raw'],
            c.plots['timeseries_raw'], c.plots['timeseries_highpassed'],
            c.plots['timeseries_whitened'], c.plots['eventgram_raw'],
            c.plots['eventgram_whitened'], c.plots['eventgram_autoscaled']
=======
            [1, 4], c.plots['qscan_whitened'], c.plots['qscan_autoscaled'],
            c.plots['qscan_raw'], c.plots['timeseries_raw'],
            c.plots['timeseries_highpassed'], c.plots['timeseries_whitened'],
            c.plots['eventgram_raw'], c.plots['eventgram_whitened'],
            c.plots['eventgram_autoscaled']
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0
        ):
            # plot whitened qscan
            fig1 = plot.omega_plot(qscan, gps, span, c.name, qscan=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig1.savefig(str(png1))
            # plot autoscaled, whitened qscan
            fig2 = plot.omega_plot(qscan, gps, span, c.name, qscan=True,
                                   colormap=args.colormap)
            fig2.savefig(str(png2))
            # plot raw qscan
            fig3 = plot.omega_plot(rqscan, gps, span, c.name, qscan=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig3.savefig(str(png3))
            # plot raw timeseries
            fig4 = plot.omega_plot(series, gps, span, c.name,
                                   ylabel='Amplitude')
            fig4.savefig(str(png4))
            # plot highpassed timeseries
            fig5 = plot.omega_plot(hpseries, gps, span, c.name,
                                   ylabel='Highpassed Amplitude')
            fig5.savefig(str(png5))
            # plot whitened timeseries
            fig6 = plot.omega_plot(wseries, gps, span, c.name,
                                   ylabel='Whitened Amplitude')
            fig6.savefig(str(png6))
            # plot raw eventgram
            fig7 = plot.omega_plot(rtable, gps, span, c.name, eventgram=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig7.savefig(str(png7))
            # plot raw eventgram
            fig8 = plot.omega_plot(table, gps, span, c.name, eventgram=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig8.savefig(str(png8))
            # plot raw eventgram
            fig9 = plot.omega_plot(table, gps, span, c.name, eventgram=True,
                                   colormap=args.colormap)
            fig9.savefig(str(png9))

        # save parameters
        c.Q = Q
        c.energy = table.Z
        c.snr = table.snr
        c.t = table.tc
        c.f = table.fc

        # delete intermediate data products
        del fig1, fig2, fig3, fig4, fig5, fig6
<<<<<<< HEAD
        del qscan, rqscan, table, rtable, series, hpseries, wseries, asd
    del data
=======
        del qscan, rqscan, table, rtable, series, hpseries, wseries
>>>>>>> a8153611f27feb598ff6d3072af02b0768c1f7c0


# -- Prepare HTML -------------------------------------------------------------

# write HTML page and finish
gprint('Preparing HTML at %s/index.html...' % outdir)
html.write_qscan_page(ifo, gps, blocks, **htmlv)
gprint("-- index.html written, all done --")

#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Compute omega scans for a list of channels around the given GPS time(s).
"""

from __future__ import division

import os.path
import re
import sys
import warnings
from StringIO import StringIO

import numpy
from numpy import fft as npfft

from matplotlib import (use, rcParams)
use('agg')

from glue.lal import Cache

from gwpy.utils import gprint
from gwpy.time import tconvert
from gwpy.table import EventTable
from gwpy.timeseries import TimeSeriesDict
from gwpy.detector import (Channel, ChannelList)
from gwpy.plotter import (figure, TimeSeriesPlot)
from gwpy.segments import (DataQualityFlag, DataQualityDict,
                           Segment, SegmentList)

from gwdetchar import (cli, const, omega, __version__)
from gwdetchar.omega import (config, plot, html)

try:
    from LDAStools import frameCPP
except ImportError:
    io_kw = {'format': 'gwf'}
else:
    io_kw = {'type': 'adc', 'format': 'gwf.framecpp'}

__author__ = 'Alex Urban <alexander.urban@ligo.org>'
__credits__ = 'Duncan Macleod <duncan.macleod@ligo.org>'


# -- parse command line -------------------------------------------------------

parser = cli.create_parser(description=__doc__)
parser.add_argument('ifo', type=str, help='IFO prefix for this analysis')
parser.add_argument('gpstime', type=str, help='GPS time of scan')
parser.add_argument('-o', '--output-directory',
                    help='output directory for the omega scan, '
                         'default: ~/public_html/wdq/{IFO}_{gpstime}')
parser.add_argument('-f', '--config-file', action='append',
    help='path to configuration file to use, can be given multiple times '
         '(files read in order), default: '
         '~detchar/etc/omega/{epoch}/{OBS}-{IFO}_R-selected.txt')
parser.add_argument('-c', '--cache-file',
    help='path to a LAL format data cache file; if not given, data locations '
         'are found using NDS')
parser.add_argument('--condor', action='store_true', default=False,
                    help='indicates this job is running under condor, '
                         'only use when running as part of a workflow')
parser.add_argument('--colormap', default='viridis',
                   help='name of colormap to use, default: %(default)s')

args = parser.parse_args()

print("----------------------------------------------\n"
      "Creating %s omega scan at GPS second %s..." % (args.ifo, args.gpstime))

gpstime = args.gpstime
gps = float(gpstime)
ifo = args.ifo
obs = ifo[0]

# set output directory
outdir = args.output_directory
if outdir is None:
    outdir = os.path.expanduser('~/public_html/wdq/%s_%s' % (ifo, gps))
if not os.path.isdir(outdir):
    os.makedirs(outdir)
os.chdir(outdir)
print("Output directory created as %s" % outdir)

# parse configuration file
cp = config.OmegaConfigParser(ifo=ifo)
cp.read(args.config_file)

# prepare html variables
htmlv = {
    'title': '%s Qscan | %s' % (ifo, gps),
    'config': args.config_file,
}

# -- FIXME: Eventually move these classes to gwdetchar.omega ------------------

class OmegaChannel(Channel):
    def __init__(self, channelname, section, **params):
        self.name = channelname
        frametype = params.get('frametype', None)
        frequency_range = tuple(
            [float(s) for s in params.get('frequency-range', None).split(',')]
        )
        super(OmegaChannel, self).__init__(channelname, frametype=frametype,
                                           frequency_range=frequency_range)
        self.plots = [
            html.FancyPlot('plots/%s_qscan_%s.png' % (self.name[3::], s))
            for s in ['short', 'med', 'long']
        ]
        self.section = section
        self.params = params.copy()

class OmegaChannelList(object):
    def __init__(self, **params):
        self.name = params.get('name', None)
        self.key = self.name.lower().replace(' ', '-')
        self.resample = int(params.get('resample', None))
        self.frametype = params.get('frametype', None)
        chans = params.get('channels', None).split(',\n')
        self.channels = [OmegaChannel(c, self.name, **params) for c in chans]
        self.params = params.copy()


# -- Compute Qscan ------------------------------------------------------------

gprint('Computing Q-scans...')

# make subdirectories
plotdir = 'plots'
aboutdir = 'about'
for d in [plotdir, aboutdir]:
    if not os.path.isdir(d):
        os.makedirs(d)

# determine channel blocks
blocks = [OmegaChannelList(**cp[s]) for s in cp.sections()]

# range over blocks
for block in blocks:
    gprint('Processing block %s' % block.name)
    chans = [c.name for c in block.channels]
    # read in 32 seconds of data
    # centered on gps
    data = TimeSeriesDict.get(chans, start=gps-32, end=gps+32,
                                frametype=block.frametype, nproc=8)
    # compute qscans
    for c in block.channels:
        # compute timeseries
        series = data[c.name].resample(block.resample)
        hpseries = series.highpass(20)
        wseries = series.whiten(64, 32).crop(gps-16, gps+16)
        # compute Q-transforms
        rqscan = series.q_transform(qrange=(4, 96),
                                    gps=gps, search=0.5, whiten=False)
        qscan = wseries.q_transform(qrange=(4, 96),
                                    gps=gps, search=0.5, whiten=False)
        for span, png in zip([.5, 2, 8], c.plots):
            png = str(png)
            # plot whitened qscan
            fig = plot.omega_plot(qscan, gps, span, colormap=args.colormap,
                                  clim=(0, 25))
            fig.savefig(png)
            # plot autoscaled, whitened qscan
            fig = plot.omega_plot(qscan, gps, span, colormap=args.colormap)
            fig.savefig(png.replace('qscan', 'autoscaled_qscan'))
            # plot raw qscan                                   
            fig = plot.omega_plot(rqscan, gps, span, colormap=args.colormap,
                                  clim=(0, 25)) 
            fig.savefig(png.replace('qscan', 'raw_qscan'))
            # plot raw timeseries
            fig = plot.omega_plot(series, gps, span, logy=False,
                                  ylabel='Strain')
            fig.savefig(png.replace('qscan', 'raw_timeseries'))
            # plot highpassed timeseries
            fig = plot.omega_plot(hpseries, gps, span, logy=False,
                                  ylabel='Highpassed Strain')
            fig.savefig(png.replace('qscan', 'highpassed_timeseries'))
            # plot whitened timeseries
            fig = plot.omega_plot(wseries, gps, span, logy=False,
                                  ylabel='Whitened Strain')
            fig.savefig(png.replace('qscan', 'whitened_timeseries'))


# -- Prepare HTML -------------------------------------------------------------

# write HTML page and finish
gprint('Preparing HTML at %s/index.html...' % outdir)
html.write_qscan_page(ifo, gps, blocks, **htmlv)
gprint("-- index.html written, all done --")

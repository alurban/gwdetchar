#!/usr/bin/env python
# coding=utf-8
# Copyright (C) LIGO Scientific Collaboration (2015-)
#
# This file is part of the GW DetChar python package.
#
# GW DetChar is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# GW DetChar is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with GW DetChar.  If not, see <http://www.gnu.org/licenses/>.

"""Compute an omega scan for a list of channels around a given GPS time.
"""

from __future__ import division

import os
import re
import sys
import warnings
from StringIO import StringIO

import numpy
from numpy import fft as npfft

from matplotlib import (use, rcParams)
use('agg')  # nopep8

from gwpy.utils import gprint
from gwpy.time import tconvert
from gwpy.timeseries import TimeSeriesDict
from gwpy.detector import (Channel, ChannelList)

from gwdetchar import (cli, __version__)
from gwdetchar.omega import (config, plot, html)

__author__ = 'Alex Urban <alexander.urban@ligo.org>'
__credits__ = 'Duncan Macleod <duncan.macleod@ligo.org>'


# -- parse command line -------------------------------------------------------

parser = cli.create_parser(description=__doc__)
parser.add_argument('ifo', type=str, help='IFO prefix for this analysis')
parser.add_argument('gpstime', type=str, help='GPS time of scan')
parser.add_argument('-o', '--output-directory',
                    help='output directory for the omega scan, '
                         'default: ~/public_html/wdq/{IFO}_{gpstime}')
parser.add_argument('-f', '--config-file', action='append', default=None,
                    help='path to configuration file to use, can be given '
                         'multiple times (files read in order), default: '
                         'None')
parser.add_argument('--condor', action='store_true', default=False,
                    help='indicates this job is running under condor, '
                         'only use when running as part of a workflow')
parser.add_argument('--colormap', default='viridis',
                    help='name of colormap to use, default: %(default)s')
parser.add_argument('-v', '--verbose', action='store_true', default='False',
                    help='print verbose output, default: %(default)s')
cli.add_nproc_option(parser)

args = parser.parse_args()

print("----------------------------------------------\n"
      "Creating %s omega scan at GPS second %s..." % (args.ifo, args.gpstime))

gpstime = args.gpstime
gps = float(gpstime)
ifo = args.ifo
obs = ifo[0]

# set output directory
outdir = args.output_directory
if outdir is None:
    outdir = os.path.expanduser('~/public_html/wdq/%s_%s' % (ifo, gps))
if not os.path.isdir(outdir):
    os.makedirs(outdir)
os.chdir(outdir)
print("Output directory created as %s" % outdir)

# parse configuration file
cp = config.OmegaConfigParser(ifo=ifo)
cp.read(args.config_file)

# prepare html variables
htmlv = {
    'title': '%s Qscan | %s' % (ifo, gps),
    'config': args.config_file,
}


# -- FIXME: Eventually move these classes to gwdetchar.omega ------------------

class OmegaChannel(Channel):
    def __init__(self, channelname, section, **params):
        self.name = channelname
        frametype = params.get('frametype', None)
        frange = tuple(
            [float(s) for s in params.get('frequency-range', None).split(',')]
        )
        super(OmegaChannel, self).__init__(channelname, frametype=frametype,
                                           frange=frange)
        self.plots = {}
        for plottype in ['timeseries_raw', 'timeseries_highpassed',
                         'timeseries_whitened', 'qscan_raw',
                         'qscan_whitened', 'qscan_autoscaled']:
            self.plots[plottype] = [get_fancyplots(self.name, plottype, t)
                                    for t in [1, 4, 16]]
        self.section = section
        self.params = params.copy()


class OmegaChannelList(object):
    def __init__(self, **params):
        self.name = params.get('name', None)
        self.key = self.name.lower().replace(' ', '-')
        self.fftlength = int(params.get('fftlength', None))
        self.resample = int(params.get('resample', None))
        self.frametype = params.get('frametype', None)
        chans = params.get('channels', None).split(',\n')
        self.channels = [OmegaChannel(c, self.name, **params) for c in chans]
        self.params = params.copy()


# -- Utilities ----------------------------------------------------------------

def get_fancyplots(channel, plottype, duration, caption=None):
    plotdir = 'plots'
    chan = channel.replace('-', '_').replace(':', '-')
    filename = '%s/%s-%s-%s.png' % (plotdir, chan, plottype, duration)
    if not caption:
        caption = os.path.basename(filename)
    return html.FancyPlot(filename, caption)


# -- Compute Qscan ------------------------------------------------------------

gprint('Computing Q-scans...')

# make subdirectories
plotdir = 'plots'
aboutdir = 'about'
for d in [plotdir, aboutdir]:
    if not os.path.isdir(d):
        os.makedirs(d)

# determine channel blocks
blocks = [OmegaChannelList(**cp[s]) for s in cp.sections()]

# range over blocks
for block in blocks:
    gprint('Processing block %s' % block.name)
    chans = [c.name for c in block.channels]
    # read in fftlength seconds of data
    # centered on gps
    fftlength = block.fftlength
    data = TimeSeriesDict.get(chans, gps-256, gps+256,
                              frametype=block.frametype, nproc=args.nproc,
                              verbose=args.verbose)
    # compute qscans
    for c in block.channels:
        if args.verbose:
            gprint('Computing omega scans for channel %s...' % c.name)
        # get raw timeseries
        series = data[c.name].resample(block.resample)
        # filter the timeseries
        hpseries = series.highpass(20)
        wseries = hpseries.whiten(fftlength, fftlength/2)
        # crop the timeseries
        wseries = wseries.crop(gps-fftlength/2, gps+fftlength/2)
        hpseries = hpseries.crop(gps-fftlength/2, gps+fftlength/2)
        # compute Q-transforms
        rqscan = hpseries.q_transform(qrange=(4, 96), frange=c.frange,
                                      tres=0.002, fres=0.1, gps=gps,
                                      search=0.25, whiten=False)
        qscan = wseries.q_transform(qrange=(4, 96), frange=c.frange,
                                    tres=0.002, fres=0.1, gps=gps,
                                    search=0.25, whiten=False)
        # prepare plots
        if args.verbose:
            gprint('Plotting omega scans for channel %s...' % c.name)
        for span, png1, png2, png3, png4, png5, png6 in zip(
            [1, 4, 16], c.plots['qscan_whitened'], c.plots['qscan_autoscaled'],
            c.plots['qscan_raw'], c.plots['timeseries_raw'],
            c.plots['timeseries_highpassed'], c.plots['timeseries_whitened']
        ):
            # plot whitened qscan
            fig1 = plot.omega_plot(qscan, gps, span, c.name, qscan=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig1.savefig(str(png1))
            # plot autoscaled, whitened qscan
            fig2 = plot.omega_plot(qscan, gps, span, c.name, qscan=True,
                                   colormap=args.colormap)
            fig2.savefig(str(png2))
            # plot raw qscan
            fig3 = plot.omega_plot(rqscan, gps, span, c.name, qscan=True,
                                   clim=(0, 25), colormap=args.colormap)
            fig3.savefig(str(png3))
            # plot raw timeseries
            fig4 = plot.omega_plot(series, gps, span, c.name,
                                   ylabel='Amplitude')
            fig4.savefig(str(png4))
            # plot highpassed timeseries
            fig5 = plot.omega_plot(hpseries, gps, span, c.name,
                                   ylabel='Highpassed Amplitude')
            fig5.savefig(str(png5))
            # plot whitened timeseries
            fig6 = plot.omega_plot(wseries, gps, span, c.name,
                                   ylabel='Whitened Amplitude')
            fig6.savefig(str(png6))
        # save parameters
        c.Q = qscan.q
        qscan = qscan.crop(gps-0.25, gps+0.25)
        c.energy = qscan.value.max()
        tind, find = numpy.unravel_index(qscan.value.argmax(),
                                         qscan.value.shape)
        c.t = qscan.xindex[tind].value
        c.f = qscan.yindex[find].value
        # delete intermediate data products
        del fig1, fig2, fig3, fig4, fig5, fig6
        del qscan, rqscan, series, hpseries, wseries


# -- Prepare HTML -------------------------------------------------------------

# write HTML page and finish
gprint('Preparing HTML at %s/index.html...' % outdir)
html.write_qscan_page(ifo, gps, blocks, **htmlv)
gprint("-- index.html written, all done --")
